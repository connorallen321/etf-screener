# -*- coding: utf-8 -*-
"""Copy - ETF Visualizer and Screener

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xti3s83blFHOzpRWbr8BiwcUYZbg9Ukh
"""

# @title

import pandas as pd
import matplotlib.pyplot as plt

# @title
from google.colab import files
uploaded = files.upload()  # Upload "Data for Colab - FT ETFs.xlsx"

# @title
import pandas as pd

# Load the Excel file
df = pd.read_excel("Data for Colab - FT ETFs.xlsx", engine="openpyxl")

# Clean up column names and tickers
df.columns = df.columns.str.strip()
df['Ticker'] = df['Ticker'].astype(str).str.strip().str.upper()

# @title
def lookup_etf_by_ticker(ticker_input):
    ticker_input = ticker_input.strip().upper()
    row = df[df['Ticker'] == ticker_input]
    if row.empty:
        return f"Ticker '{ticker_input}' not found."
    return {
        "Cap Level ($)": row.iloc[0]['Cap Value'],
        "Current Price ($)": row.iloc[0]['Fund Value'],
        "Buffer Start ($)": row.iloc[0]['Buffer Start Price'],
        "Buffer End ($)": row.iloc[0]['Buffer End Price']
    }

def plot_etf_bar_chart(ticker_input):
    data = lookup_etf_by_ticker(ticker_input)
    if isinstance(data, str):
        print(data)
        return

    cap = float(data["Cap Level ($)"])
    current = float(data["Current Price ($)"])
    buffer_start = float(data["Buffer Start ($)"])
    buffer_end = float(data["Buffer End ($)"])
    floor = 0.0

    top = max(cap, current)
    bottom = min(floor, buffer_end)

    segments = []

    # Green zone: Cap to Current (if cap > current)
    if cap > current:
        segments.append((cap, current, 'green', f'{(cap/current - 1) * 100:.2f}%'))

    # Handle buffer logic
    if current > buffer_start:
        # Red: current → buffer_start
        segments.append((current, buffer_start, 'red', f'{(buffer_start/current - 1) * 100:.2f}%'))
        # Gray: buffer_start → buffer_end
        segments.append((buffer_start, buffer_end, 'gray', f'{(buffer_end/buffer_start - 1) * 100:.2f}%'))
    else:
        # Entire range: current → buffer_end is in gray
        segments.append((current, buffer_end, 'gray', f'{(buffer_end/current - 1) * 100:.2f}%'))

    # Red: buffer_end → floor
    segments.append((buffer_end, floor, 'red', f'{(floor/buffer_end - 1) * 100:.2f}%'))

    # Plotting
    fig, ax = plt.subplots(figsize=(4, 8))

    for top_val, bottom_val, color, label in segments:
        height = abs(top_val - bottom_val)
        lower = min(top_val, bottom_val)
        ax.bar(x=0, height=height, width=0.5, bottom=lower, color=color, edgecolor='black')
        ax.text(0, lower + height / 2, label, ha='center', va='center', fontsize=9)

    # Horizontal lines + labels
    levels = [('Cap', cap), ('Current Price', current),
              ('Buffer End', buffer_end), ('Floor', floor)]

    if current > buffer_start:
        levels.insert(2, ('Buffer Start', buffer_start))

    for name, value in levels:
        ax.hlines(y=value, xmin=-0.3, xmax=0.3, color='black', linewidth=1)
        ax.text(0.35, value, f"{name} | ${value:.2f}", va='center', fontsize=9)

    ax.set_xlim(-0.5, 1.0)
    ax.set_ylim(bottom, top)
    ax.axis('off')
    plt.title(f"{ticker_input.upper()} Outcome Range", fontsize=14, fontweight='bold', pad=20)
    plt.tight_layout()
    plt.show()

# @title
import ipywidgets as widgets
from IPython.display import display, clear_output

# --- Create selection dropdown ---
filter_options = ['Show ETF\'s near cap', 'Show High Downside Risk', 'Show ETFs close to buffer end']
filter_dropdown = widgets.Dropdown(
    options=filter_options,
    description='Screen:',
    layout=widgets.Layout(width='300px')
)

# --- Output area for filtered ETF list ---
filter_output = widgets.Output()

# --- Filtering logic ---
def update_filter_display(change):
    with filter_output:
        clear_output()

        # Recalculate metrics
        df['% to Cap'] = (df['Cap Value'] / df['Fund Value']) - 1
        df['% to Buffer Start'] = (df['Buffer Start Price'] / df['Fund Value']) - 1
        df['% to Buffer End'] = (df['Fund Value'] / df['Buffer End Price']) - 1  # New metric

        if change['new'] == 'Show ETF\'s near cap':
            filtered = df[df['% to Cap'] < 0.05][['Ticker', 'Days Remaining', 'Fund Value', 'Cap Value', '% to Cap']]
            print("ETFs with <5% Upside to Cap:\n")
            display(filtered)

        elif change['new'] == 'Show High Downside Risk':
            filtered = df[df['% to Buffer Start'] < -0.05][['Ticker', 'Days Remaining', 'Fund Value', 'Buffer Start Price', '% to Buffer Start']]
            print("ETFs with >5% Downside to Buffer Start:\n")
            display(filtered)

        elif change['new'] == 'Show ETFs close to buffer end':
            filtered = df[df['% to Buffer End'] < 0.05][['Ticker', 'Days Remaining', 'Fund Value', 'Buffer End Price', '% to Buffer End']]
            print("ETFs within 5% of Buffer End:\n")
            display(filtered)

# Attach function to dropdown
filter_dropdown.observe(update_filter_display, names='value')

# Display everything
display(filter_dropdown, filter_output)

# @title
import ipywidgets as widgets
from IPython.display import display, clear_output

# Create dropdown from ticker list
tickers = sorted(df['Ticker'].dropna().unique().tolist())
dropdown = widgets.Dropdown(
    options=tickers,
    description='ETF Ticker:',
    layout=widgets.Layout(width='300px')
)

# Output area
output_area = widgets.Output()

# Define behavior on selection
def on_dropdown_change(change):
    if change['type'] == 'change' and change['name'] == 'value':
        ticker = change['new']
        data = lookup_etf_by_ticker(ticker)

        with output_area:
            clear_output()
            # Print key ETF data
            if isinstance(data, dict):
                print(f"\n--- Results for {ticker} ---")
                for k, v in data.items():
                    print(f"{k}: ${float(v):.2f}")
                # Show chart
                plot_etf_bar_chart(ticker)
            else:
                print(data)

# Link dropdown to function
dropdown.observe(on_dropdown_change)

# Display the dropdown and the output area
display(dropdown, output_area)

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import requests

st.set_page_config(page_title="Buffered ETF Visualizer", layout="centered")
st.title("Buffered ETF Outcome Visualizer")

# --- Load data from public Google Sheets link ---
# Replace with your own sheet's export URL
sheet_url = "https://docs.google.com/spreadsheets/d/1Aj52geXqPzCZNKM_wPfJCdPWAODClLb1EAyi4SmZxgQ/export?format=csv"
df = pd.read_csv(sheet_url)

# Convert key columns to numbers
cols_to_convert = ['Cap Value', 'Fund Value', 'Buffer Start Price', 'Buffer End Price']
for col in cols_to_convert:
    df[col] = pd.to_numeric(df[col], errors='coerce')


# Clean and process data
df.columns = df.columns.str.strip()
df['Ticker'] = df['Ticker'].astype(str).str.strip().str.upper()
df['% to Cap'] = (df['Cap Value'] / df['Fund Value']) - 1
df['% to Buffer Start'] = (df['Buffer Start Price'] / df['Fund Value']) - 1
df['% to Buffer End'] = (df['Buffer End Price'] / df['Fund Value']) - 1

# --- Screener Dropdown ---
st.subheader("ETF Screener")
screener_option = st.selectbox("Choose filter:", [
    "Show ETF's near cap",
    "Show High Downside Risk",
    "Show ETFs near buffer end"
])

if screener_option == "Show ETF's near cap":
    filtered_df = df[df['% to Cap'] < 0.05][['Ticker', 'Fund Value', 'Cap Value', '% to Cap']]
    st.write("ETFs with <5% Upside to Cap")
    st.dataframe(filtered_df)
elif screener_option == "Show High Downside Risk":
    filtered_df = df[df['% to Buffer Start'] < -0.05][['Ticker', 'Fund Value', 'Buffer Start Price', '% to Buffer Start']]
    st.write("ETFs with >5% Downside to Buffer Start")
    st.dataframe(filtered_df)
elif screener_option == "Show ETFs near buffer end":
    filtered_df = df[df['% to Buffer End'] < 0.05][['Ticker', 'Fund Value', 'Buffer End Price', '% to Buffer End']]
    st.write("ETFs within 5% of Buffer End Level")
    st.dataframe(filtered_df)

# --- Chart Visualizer ---
st.subheader("ETF Chart Viewer")
ticker = st.selectbox("Select an ETF to visualize:", df['Ticker'].unique())
row = df[df['Ticker'] == ticker].iloc[0]

cap = float(row['Cap Value'])
current = float(row['Fund Value'])
buffer_start = float(row['Buffer Start Price'])
buffer_end = float(row['Buffer End Price'])
floor = 0.0

segments = []
if cap > current:
    segments.append((cap, current, 'green', f'{(cap/current - 1)*100:.2f}%'))
if current > buffer_start:
    segments.append((current, buffer_start, 'red', f'{(buffer_start/current - 1)*100:.2f}%'))
    segments.append((buffer_start, buffer_end, 'gray', f'{(buffer_end/buffer_start - 1)*100:.2f}%'))
else:
    segments.append((current, buffer_end, 'gray', f'{(buffer_end/current - 1)*100:.2f}%'))
segments.append((buffer_end, floor, 'red', f'{(floor/buffer_end - 1)*100:.2f}%'))

# --- Plot Chart ---
def plot_chart():
    top = max(cap, current)
    bottom = min(floor, buffer_end)

    fig, ax = plt.subplots(figsize=(4, 8))
    for top_val, bottom_val, color, label in segments:
        height = abs(top_val - bottom_val)
        lower = min(top_val, bottom_val)
        ax.bar(0, height, width=0.5, bottom=lower, color=color, edgecolor='black')
        ax.text(0, lower + height / 2, label, ha='center', va='center', fontsize=9)

    levels = [('Cap', cap), ('Current Price', current), ('Buffer End', buffer_end), ('Floor', floor)]
    if current > buffer_start:
        levels.insert(2, ('Buffer Start', buffer_start))

    for name, value in levels:
        ax.hlines(y=value, xmin=-0.3, xmax=0.3, color='black', linewidth=1)
        ax.text(0.35, value, f"{name} | ${value:.2f}", va='center', fontsize=9)

    ax.set_xlim(-0.5, 1.0)
    ax.set_ylim(bottom, top)
    ax.axis('off')
    plt.title(f"{ticker} Outcome Range", fontsize=14, fontweight='bold', pad=20)
    return fig

fig = plot_chart()
st.pyplot(fig)